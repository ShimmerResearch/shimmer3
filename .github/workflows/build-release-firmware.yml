name: LogAndStream S3 Build & Release

on:
  # push:
  #   branches:
  #     - main
  workflow_dispatch:
    inputs:
      increment:
        description: "Which version part to increment (vMAJOR.MINOR.PATCH)?"
        required: true
        default: "patch"
        type: choice
        options:
          - major
          - minor
          - patch
      build_mode:
        description: "Select build mode:"
        required: true
        default: "Debug"
        type: choice
        options:
          - Release
          - Debug

permissions:
  contents: write  # Needed for git commit/push and tag creation

env:
  PROJECT_NAME: LogAndStream
  PROJECT_DIR: LogAndStream
  BUILD_CONFIG: ${{ github.event.inputs.build_mode }}
  TAG_PREFIX: LogAndStream_Shimmer3_v
  JIRA_VERSION_PREFIX: 'L&S_S3_v'   # note the quotes due to &
  CCS_VERSION: 12.8.1.00005
  CCS_TAR: CCS12.8.1.00005_linux-x64.tar.gz
  CCS_INSTALL_DIR: /opt/ti/ccs
  SUBMODULE_FOLDER: log-and-stream-common
  SUBMODULE_REPO: ShimmerResearch/log-and-stream-common

jobs:
  build:
    runs-on: ubuntu-22.04
    steps:
      - name: Checkout code (with submodules)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Needed for tags and versioning
          submodules: recursive  # Ensures submodules are fetched

      - name: Debug path
        run: pwd

      - name: Debug contents
        run: ls

      - name: Debug directory structure
        run: |
          ls -lR ${{ env.PROJECT_DIR }}/${{ env.SUBMODULE_FOLDER }}/scripts

      - name: Normalize line endings
        run: |
          sudo apt-get update
          sudo apt-get install -y dos2unix
          dos2unix '${{ env.PROJECT_DIR }}'/${{ env.SUBMODULE_FOLDER }}/scripts/*.sh || true

      - name: Increment version
        run: |
          set -euo pipefail
          inc="${{ github.event.inputs.increment }}"
          [ -z "$inc" ] && inc=patch
          chmod +x '${{ env.PROJECT_DIR }}/${{ env.SUBMODULE_FOLDER }}/scripts/increment_version.sh'
          '${{ env.PROJECT_DIR }}/${{ env.SUBMODULE_FOLDER }}/scripts/increment_version.sh' "$inc"

      - name: Save version for next steps
        id: get_version
        run: |
          set -euo pipefail
          VERSION=$(cat "${{ env.PROJECT_DIR }}/build/version.txt")
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"

      - name: Install prerequisites
        run: |
          set -e
          sudo apt-get update
          sudo apt-get install -y wget xz-utils libusb-1.0-0 \
            libxext6 libxrender1 libxtst6 libxi6 libglib2.0-0 libgtk2.0-0 libnss3 ca-certificates \
            tar gzip coreutils findutils libtinfo5
          #rm -rf /var/lib/apt/lists/*

      - name: Cache CCS
        id: ccs-cache
        uses: actions/cache@v4
        with:
            # use the absolute install dir directly
          path: ${{ env.CCS_INSTALL_DIR }}
          key: ccs-${{ env.CCS_VERSION }}

      - name: Download CCS (if cache miss)
        if: steps.ccs-cache.outputs.cache-hit != 'true'
        run: |
          set -euo pipefail
          URL="https://dr-download.ti.com/software-development/ide-configuration-compiler-or-debugger/MD-J1VdearkvK/12.8.1/CCS${CCS_VERSION}_linux-x64.tar.gz"
          echo "Downloading: $URL"
          wget -q "$URL" -O /tmp/ccs.tar.gz
          ls -l /tmp/ccs.tar.gz
            SIZE=$(stat -c%s /tmp/ccs.tar.gz)
          echo "Archive size: $SIZE bytes"
          [ "$SIZE" -gt 500000000 ] || { echo "Archive too small"; exit 1; }
          mkdir -p /tmp/ccs
          tar -xzf /tmp/ccs.tar.gz -C /tmp/ccs
          echo "Validate archive (first 10 entries):"
           #Avoid SIGPIPE by using sed instead of head
          tar -tzf /tmp/ccs.tar.gz | sed -n '1,10p'
          echo "Top-level extracted:"

      - name: Inspect extracted installer
        if: steps.ccs-cache.outputs.cache-hit != 'true'
        run: |
          set -euo pipefail
          INSTALLER_DIR=$(find /tmp/ccs -maxdepth 1 -type d -name "CCS${CCS_VERSION}_linux-x64")
          [ -n "$INSTALLER_DIR" ] || { echo "Installer dir not found"; exit 1; }
          find "$INSTALLER_DIR" -maxdepth 2 -type f -printf '%P (%k KB)\n' | head -n 40
          INSTALLER="$INSTALLER_DIR/ccs_setup_${CCS_VERSION}.run"
          [ -f "$INSTALLER" ] || { echo "Installer binary missing"; exit 1; }
          chmod +x "$INSTALLER"
          file "$INSTALLER"

      - name: Install CCS unattended
        if: steps.ccs-cache.outputs.cache-hit != 'true'
        run: |
          set -euo pipefail
          set -x
          mkdir -p /opt/ti
          INSTALLER=$(find /tmp/ccs -maxdepth 4 -type f -name "ccs_setup_*.run" | head -n1)
          test -n "$INSTALLER"
          chmod +x "$INSTALLER"
          #"$INSTALLER" --help | sed -n '1,120p' || true
          PREFIX=/opt/ti/ccs
          # Choose components: remove --enable-components to install defaults
          # Example enables only MSP430; adjust as needed.
          "$INSTALLER" \
            --mode unattended \
            --unattendedmodeui none \
            --prefix "$PREFIX" \
            --enable-components PF_MSP430 \
            --debuglevel 4
          INSTALL_RC=${INSTALL_RC:-0}
          echo "Installer exit code: $INSTALL_RC"
          if [ $INSTALL_RC -ne 0 ] || [ ! -d "$PREFIX" ]; then
            exit 1
          fi
          echo "Install tree depth 3:"
          find "$PREFIX" -maxdepth 3 -type d -print
      
      - name: Locate Eclipse
        id: loc
        run: |
          set -euo pipefail
          if [ -x "${CCS_INSTALL_DIR}/eclipse/eclipse" ]; then
            E="${CCS_INSTALL_DIR}/eclipse/eclipse"
          elif [ -x "${CCS_INSTALL_DIR}/ccs/eclipse/eclipse" ]; then
            E="${CCS_INSTALL_DIR}/ccs/eclipse/eclipse"
          else
            echo "Eclipse not found:"
            find "${CCS_INSTALL_DIR}" -maxdepth 5 -name eclipse -print || true
            exit 1
          fi
          echo "eclipse_bin=$E" >> "$GITHUB_OUTPUT"
          "$E" -noSplash -application com.ti.ccstudio.apps.projectBuild -help | head -n 20 || true

      - name: Verify CCS
        run: |
          set -euo pipefail
          "${{ steps.loc.outputs.eclipse_bin }}" -noSplash -application com.ti.ccstudio.apps.projectBuild -help | head -n 15 || true

      - name: Cache imported workspace (optional)
        id: ws-cache
        uses: actions/cache@v4
        with:
          path: ccs_workspace
          key: ccs-ws-${{ env.CCS_VERSION }}-${{ hashFiles('**/.project') }}

      - name: Import project (if workspace cache miss)
        if: steps.ws-cache.outputs.cache-hit != 'true'
        run: |
          "${{ steps.loc.outputs.eclipse_bin }}" \
            -noSplash \
            -data "${GITHUB_WORKSPACE}/ccs_workspace" \
            -application com.ti.ccstudio.apps.projectImport \
            -ccs.location "${GITHUB_WORKSPACE}/${PROJECT_NAME}"

      - name: Build project
        run: |
          "${{ steps.loc.outputs.eclipse_bin }}" \
            -noSplash \
            -data "${GITHUB_WORKSPACE}/ccs_workspace" \
            -application com.ti.ccstudio.apps.projectBuild \
            -ccs.projects "${PROJECT_NAME}" \
            -ccs.configuration "${BUILD_CONFIG}" \
            -ccs.cleanBuild

      - name: Collect TI TXT
        run: |
          set -euo pipefail
          mkdir -p build
          TXT=$(find '${{ env.PROJECT_DIR }}' -type f -path "*/${{ env.BUILD_CONFIG }}/*.txt" | head -n1 || true)
          [ -z "$TXT" ] && { echo "No txt produced"; exit 1; }
          cp "$TXT" "build/${{ env.TAG_PREFIX }}${{ steps.get_version.outputs.version }}.txt"

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: "${{ env.TAG_PREFIX }}${{ steps.get_version.outputs.version }}"
          path: |
            ${{ env.PROJECT_DIR }}/${{ env.BUILD_CONFIG }}/*.out
            build/*.txt
            Debug/*.txt
            Release/*.txt

      - name: Commit version bump
        run: |
          git config user.name github-actions
          git config user.email github-actions@github.com
          git add '${{ env.PROJECT_DIR }}/build/version.txt' '${{ env.PROJECT_DIR }}/Shimmer_Driver/version.h'
          git commit -m "chore: bump firmware version to v${{ steps.get_version.outputs.version }}" || true
          git push

      - name: Create Git tag
        run: |
          set -euo pipefail
          git config user.name "github-actions"
          git config user.email "github-actions@github.com"
          git tag "${{ env.TAG_PREFIX }}${{ steps.get_version.outputs.version }}"
          git push origin "${{ env.TAG_PREFIX }}${{ steps.get_version.outputs.version }}"

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ env.TAG_PREFIX }}${{ steps.get_version.outputs.version }}
          name: "${{ env.TAG_PREFIX }}${{ steps.get_version.outputs.version }}"
          generate_release_notes: true
          files: build/*.txt
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # Link main repo issues to Jira issues
      - name: Link GitHub release to Jira
        env:
          JIRA_BASE_URL: ${{ secrets.JIRA_BASE_URL }}
          JIRA_USER_EMAIL: ${{ secrets.JIRA_USER_EMAIL }}
          JIRA_API_TOKEN: ${{ secrets.JIRA_API_TOKEN }}
          JIRA_PROJECT_KEY: DEV
          GH_TAG_PREFIX: ${{ env.TAG_PREFIX }}
          JIRA_VERSION_PREFIX: ${{ env.JIRA_VERSION_PREFIX }}
        run: |
          set -euo pipefail
          VERSION='${{ steps.get_version.outputs.version }}'
          RELEASE_TAG="${GH_TAG_PREFIX}${VERSION}"
          JIRA_VERSION="${JIRA_VERSION_PREFIX}${VERSION}"

          git fetch --tags --quiet || true

          PREV_TAG=$(git describe --tags --abbrev=0 "${RELEASE_TAG}^" 2>/dev/null || echo "")
          RANGE=$([ -n "$PREV_TAG" ] && echo "$PREV_TAG..$RELEASE_TAG" || echo "$RELEASE_TAG")

          ISSUE_KEYS=$(git log --format='%s%n%b' $RANGE | grep -Eo '[A-Z][A-Z0-9]+-[0-9]+' | sort -u || true)
          [ -z "$ISSUE_KEYS" ] && echo "No Jira issue keys found; skipping." && exit 0

          PROJECT_JSON=$(curl -s -u "$JIRA_USER_EMAIL:$JIRA_API_TOKEN" \
            -H 'Accept: application/json' "$JIRA_BASE_URL/rest/api/3/project/$JIRA_PROJECT_KEY")
          PROJECT_ID=$(echo "$PROJECT_JSON" | jq -r '.id // empty')
          [ -z "$PROJECT_ID" ] && echo "Failed to resolve project id" && echo "$PROJECT_JSON" && exit 1

          VERSIONS_JSON=$(curl -s -u "$JIRA_USER_EMAIL:$JIRA_API_TOKEN" \
            -H 'Accept: application/json' "$JIRA_BASE_URL/rest/api/3/project/$JIRA_PROJECT_KEY/versions")

          # Normalize to an array, then pick the first matching version id (if any)
          EXISTING_VERSION_ID=$(echo "$VERSIONS_JSON" | jq -r --arg NAME "$JIRA_VERSION" '
            (.values? // .)                                     # paginated object or bare array
            | (if type=="array" then . else [] end)             # ensure array
            | map(select(.name==$NAME)) | .[0]? | .id? // empty # select by name
          ')

          if [ -z "$EXISTING_VERSION_ID" ]; then
            CREATE_RESP=$(jq -nc --arg name "$JIRA_VERSION" --arg pid "$PROJECT_ID" --arg date "$(date -u +%Y-%m-%d)" \
              '{name:$name, projectId:($pid|tonumber), released:true, releaseDate:$date}' \
              | curl -s -u "$JIRA_USER_EMAIL:$JIRA_API_TOKEN" -H 'Content-Type: application/json' \
                -d @- "$JIRA_BASE_URL/rest/api/3/version")
            VERSION_ID=$(echo "$CREATE_RESP" | jq -r '.id // empty')
            [ -z "$VERSION_ID" ] && echo "Failed to create Jira version" && echo "$CREATE_RESP" && exit 1
          else
            VERSION_ID="$EXISTING_VERSION_ID"
          fi

          while read -r KEY; do
            [ -z "$KEY" ] && continue
            curl -s -o /dev/null -w "%{http_code}\n" \
              -u "$JIRA_USER_EMAIL:$JIRA_API_TOKEN" \
              -H 'Content-Type: application/json' \
              -X PUT \
              --data "$(jq -nc --arg v "$JIRA_VERSION" '{update:{fixVersions:[{add:{name:$v}}]}}')" \
              "$JIRA_BASE_URL/rest/api/3/issue/$KEY" | grep -qE '^(204|200)$' || echo "Failed to update $KEY"
          done <<< "$ISSUE_KEYS"

      # Create tag and release in submodule
      - name: Remove actions auth header
        run: |
          git config --unset-all http.https://github.com/.extraheader || true
          git -C '${{ env.PROJECT_DIR }}/${{ env.SUBMODULE_FOLDER }}' config --unset-all http.https://github.com/.extraheader || true

      - name: Prepare submodule remote with PAT
        run: |
          set -euo pipefail
          SUB_PATH='${{ env.PROJECT_DIR }}/${{ env.SUBMODULE_FOLDER }}'
          # Safety: remove any lingering auth header
          git -C "$SUB_PATH" config --unset-all http.https://github.com/.extraheader || true
          # Set remote URL with PAT
          git -C "$SUB_PATH" remote set-url origin "https://${{ secrets.SUBMODULE_PUSH_USER }}:${{ secrets.SUBMODULE_PUSH_TOKEN }}@github.com/${{ env.SUBMODULE_REPO }}.git"
          git -C "$SUB_PATH" remote -v
      
      - name: Tag submodule ${{ env.SUBMODULE_FOLDER }}
        working-directory: ${{ env.PROJECT_DIR }}/${{ env.SUBMODULE_FOLDER }}
        run: |
          set -euo pipefail
          tag='${{ env.TAG_PREFIX }}${{ steps.get_version.outputs.version }}'
          git fetch --tags origin
          if git rev-parse "$tag" >/dev/null 2>&1; then
            echo "Tag $tag already exists. Skipping."
            exit 0
          fi
          git config user.name "${{ secrets.SUBMODULE_PUSH_USER }}"
          git config user.email "${{ secrets.SUBMODULE_PUSH_USER }}@users.noreply.github.com"
          git tag -a "$tag" -m "Release $tag"
          # Push via explicit URL (ensures PAT is used even if remote not rewritten)
          git push "https://${{ secrets.SUBMODULE_PUSH_USER }}:${{ secrets.SUBMODULE_PUSH_TOKEN }}@github.com/${{ env.SUBMODULE_REPO }}.git" "$tag"

      - name: Create GitHub Release in submodule
        env:
          GH_TOKEN: ${{ secrets.SUBMODULE_PUSH_TOKEN }}
          TAG: ${{ env.TAG_PREFIX }}${{ steps.get_version.outputs.version }}
        run: |
          set -euo pipefail
          if gh release view "$TAG" -R "${{ env.SUBMODULE_REPO }}" >/dev/null 2>&1; then
            echo "Release $TAG already exists in $SUBMODULE_REPO; skipping."
          else
            # Add files (e.g., `build/*.txt`) after "$TAG" if you want to attach assets
            gh release create "$TAG" -R "${{ env.SUBMODULE_REPO }}" --title "$TAG" --generate-notes
          fi

      # Link submodule repo issues to Jira issues
      - name: Link GitHub release to Jira
        working-directory: ${{ env.PROJECT_DIR }}/${{ env.SUBMODULE_FOLDER }}
        env:
          JIRA_BASE_URL: ${{ secrets.JIRA_BASE_URL }}
          JIRA_USER_EMAIL: ${{ secrets.JIRA_USER_EMAIL }}
          JIRA_API_TOKEN: ${{ secrets.JIRA_API_TOKEN }}
          JIRA_PROJECT_KEY: DEV
          GH_TAG_PREFIX: ${{ env.TAG_PREFIX }}
          JIRA_VERSION_PREFIX: ${{ env.JIRA_VERSION_PREFIX }}
        run: |
          set -euo pipefail
          VERSION='${{ steps.get_version.outputs.version }}'
          RELEASE_TAG="${GH_TAG_PREFIX}${VERSION}"
          JIRA_VERSION="${JIRA_VERSION_PREFIX}${VERSION}"

          git fetch --tags --quiet || true

          PREV_TAG=$(git describe --tags --abbrev=0 "${RELEASE_TAG}^" 2>/dev/null || echo "")
          RANGE=$([ -n "$PREV_TAG" ] && echo "$PREV_TAG..$RELEASE_TAG" || echo "$RELEASE_TAG")

          ISSUE_KEYS=$(git log --format='%s%n%b' $RANGE | grep -Eo '[A-Z][A-Z0-9]+-[0-9]+' | sort -u || true)
          [ -z "$ISSUE_KEYS" ] && echo "No Jira issue keys found; skipping." && exit 0

          PROJECT_JSON=$(curl -s -u "$JIRA_USER_EMAIL:$JIRA_API_TOKEN" \
            -H 'Accept: application/json' "$JIRA_BASE_URL/rest/api/3/project/$JIRA_PROJECT_KEY")
          PROJECT_ID=$(echo "$PROJECT_JSON" | jq -r '.id // empty')
          [ -z "$PROJECT_ID" ] && echo "Failed to resolve project id" && echo "$PROJECT_JSON" && exit 1

          VERSIONS_JSON=$(curl -s -u "$JIRA_USER_EMAIL:$JIRA_API_TOKEN" \
            -H 'Accept: application/json' "$JIRA_BASE_URL/rest/api/3/project/$JIRA_PROJECT_KEY/versions")

          # Normalize to an array, then pick the first matching version id (if any)
          EXISTING_VERSION_ID=$(echo "$VERSIONS_JSON" | jq -r --arg NAME "$JIRA_VERSION" '
            (.values? // .)                                     # paginated object or bare array
            | (if type=="array" then . else [] end)             # ensure array
            | map(select(.name==$NAME)) | .[0]? | .id? // empty # select by name
          ')

          if [ -z "$EXISTING_VERSION_ID" ]; then
            CREATE_RESP=$(jq -nc --arg name "$JIRA_VERSION" --arg pid "$PROJECT_ID" --arg date "$(date -u +%Y-%m-%d)" \
              '{name:$name, projectId:($pid|tonumber), released:true, releaseDate:$date}' \
              | curl -s -u "$JIRA_USER_EMAIL:$JIRA_API_TOKEN" -H 'Content-Type: application/json' \
                -d @- "$JIRA_BASE_URL/rest/api/3/version")
            VERSION_ID=$(echo "$CREATE_RESP" | jq -r '.id // empty')
            [ -z "$VERSION_ID" ] && echo "Failed to create Jira version" && echo "$CREATE_RESP" && exit 1
          else
            VERSION_ID="$EXISTING_VERSION_ID"
          fi

          while read -r KEY; do
            [ -z "$KEY" ] && continue
            curl -s -o /dev/null -w "%{http_code}\n" \
              -u "$JIRA_USER_EMAIL:$JIRA_API_TOKEN" \
              -H 'Content-Type: application/json' \
              -X PUT \
              --data "$(jq -nc --arg v "$JIRA_VERSION" '{update:{fixVersions:[{add:{name:$v}}]}}')" \
              "$JIRA_BASE_URL/rest/api/3/issue/$KEY" | grep -qE '^(204|200)$' || echo "Failed to update $KEY"
          done <<< "$ISSUE_KEYS"

      - name: Mark Jira version as released
        env:
          JIRA_BASE_URL: ${{ secrets.JIRA_BASE_URL }}
          JIRA_USER_EMAIL: ${{ secrets.JIRA_USER_EMAIL }}
          JIRA_API_TOKEN: ${{ secrets.JIRA_API_TOKEN }}
          JIRA_PROJECT_KEY: DEV
          JIRA_VERSION_PREFIX: ${{ env.JIRA_VERSION_PREFIX }}
        run: |
          set -euo pipefail
          VERSION='${{ steps.get_version.outputs.version }}'
          JIRA_VERSION="${JIRA_VERSION_PREFIX}${VERSION}"
          RELEASE_DATE="$(date -u +%Y-%m-%d)"
      
          PROJECT_JSON=$(curl -s -u "$JIRA_USER_EMAIL:$JIRA_API_TOKEN" \
            -H 'Accept: application/json' "$JIRA_BASE_URL/rest/api/3/project/$JIRA_PROJECT_KEY")
          PROJECT_ID=$(echo "$PROJECT_JSON" | jq -r '.id // empty')
          [ -z "$PROJECT_ID" ] && echo "Failed to resolve project id" && echo "$PROJECT_JSON" && exit 1
      
          VERSIONS_JSON=$(curl -s -u "$JIRA_USER_EMAIL:$JIRA_API_TOKEN" \
            -H 'Accept: application/json' "$JIRA_BASE_URL/rest/api/3/project/$JIRA_PROJECT_KEY/versions")
          VERSION_ID=$(echo "$VERSIONS_JSON" | jq -r --arg NAME "$JIRA_VERSION" '
            (.values? // .)
            | (if type=="array" then . else [] end)
            | map(select(.name==$NAME)) | .[0]? | .id? // empty
          ')
      
          if [ -z "$VERSION_ID" ]; then
            CREATE_RESP=$(jq -nc --arg name "$JIRA_VERSION" --arg pid "$PROJECT_ID" --arg date "$RELEASE_DATE" \
              '{name:$name, projectId:($pid|tonumber), released:true, releaseDate:$date}' \
              | curl -s -u "$JIRA_USER_EMAIL:$JIRA_API_TOKEN" -H 'Content-Type: application/json' \
                -d @- "$JIRA_BASE_URL/rest/api/3/version")
            VERSION_ID=$(echo "$CREATE_RESP" | jq -r '.id // empty')
            [ -z "$VERSION_ID" ] && echo "Failed to create Jira version" && echo "$CREATE_RESP" && exit 1
          else
            HTTP=$(jq -nc --arg date "$RELEASE_DATE" '{released:true, releaseDate:$date}' \
              | curl -s -o /dev/null -w "%{http_code}\n" -u "$JIRA_USER_EMAIL:$JIRA_API_TOKEN" \
                -H 'Content-Type: application/json' -X PUT -d @- \
                "$JIRA_BASE_URL/rest/api/3/version/$VERSION_ID")
            echo "Jira update status: $HTTP"
            echo "$HTTP" | grep -qE '^(200|204)$' || { echo "Failed to mark Jira version released"; exit 1; }
          fi
